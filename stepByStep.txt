SECTION 9: Sever setup
- Tạo file đầu tiên với express
- Sử dụng cú pháp ES6 import file ( sửa ở trong pakage.json)
- tạo folder middleware, handle routes không tìm thấy ở đó ( lỗi trả về status(404) 
- Tạo thêm 1 file để catch lỗi 500, lỗi này thường là một middleware 4 parameter (err, req, res, next)
 + Ở những routers nếu có lỗi thì throw new Error(cho lỗi ở đây) => bên middleware trên sẽ bắt được ở err ( có thể log ra xem)
 + Và trả về status(500).json({ định nghĩa 1 lỗi khác trong này })
- Kết nối với mongoose, để ý những option khi lên ver mới sẽ không cần cho vào nữa

SECTION 10:Routes and structure Controller
- Tạo controller, router cho job và auth ( thêm sửa xóa, lấy tất cả)
- Test bằng Postman đã hoàn thiện 

SECTION 11: Tạo User model va validate email
SECTION 12: Liên kết với contrller ( try catch để bắt lỗi khi không pass)
- Đẩy hết lỗi vào middleware đã tạo ( tại contrller phần catch khi rơi vào đó thì
next(err) => nó sẽ đẩy lỗi về middler 4 parmeter đã có sẵn
- express-async-errors: Dùng thư viện này nó sẽ hỗ trợ việc k phải viết try cacth nữa, lỗi sẽ được tự next()
- Thêm một thư viện để tự sinh ra statusCode mã lỗi sẽ được render ra

SECTION 13: Handdler các lỗi về input 
- Tạo các logic ở file file err middleware, nhận lỗi và trả về ở đây
	+ Object.values() => 1 obj nó sẽ trả về các giá trị đằng sau của key dạng mảng
	+ Object.keys() => 1 obj sẽ được trả về key của thuộc tính dưới dạng 1 array 
- validate chi tiết từng trường ô input, sau đó mới toàn bộ ( dùng một cái class fc)
- tạo 3 cái class fc, 1 cái extent Error, 2 cái còn lại phụ thuộc cái cha này, extend nó (badrequest, not-found)
- Tách ra 1 folder errors riêng, rồi import nó vào, chú ý đuôi js
- Kiểm tra tồn tại email hay chưa rồi thông báo lỗi về
SECTION 14: haspassword
- Dùng bcrypt để haspass (lần này hash ở trong model k phải trong controller)
- chú ý đọc doc của mongoose ( QUAN TRỌNG)

SECTION 15: JWT
- Tạo 1 fc trong model User luôn dạng,  UserSchema.methods.createJWT
- Ở bên authconller, do đã có const user = User.create() => user.createJWT()
+ Tạo biến để lưu nó lại, rồi trả về kèm với người dùng
SECTION 16: Kết nối B.E VS F.E
- config lại file package.json ( ở phía server)
 + "client":"npm start --prefix client" => chú ý tên file f.e xem có cần trùng không
- Dùng fetch hay axios ở f.e để kết nối đều sẽ gặp CORS Errors, cần hiểu và confix cái này
- Dùng 1 pakage là core import vào phía server rồi bên f.e dùng fetch để lấy sẽ được ( chú ý dữ liệu từ server trả về phải ở dạng res.json() )
- SyntaxError: Unexpected token R in JSON at position 0 ( LỖI NÀY TỪ SV TRẢ VỀ )
- Tìm hiểu PROXY 

SECTION 17: Register User F.E
- Dùng axios để kết nối, nhớ những cái config ở action, ruducer, appContext
 + POST thì cần gửi kèm data lên server ( chú ý kết quả trả về của axios, cả phần errr phải .response để hiển thị lỗi trả về )
- Dùng useNavigate để chuyển hướng ( những bản trước hay dùng history)
 - Sau khi đăng ký thì lưu thông tin ở dưới localStorage ( tạo hàm ở appContext)
+ Tạo hàm xong khi đăng ký thành công thì mới chạy hàm đó => code bên trong sẽ được thực thi
+ set lại cái initial nếu có sẽ lấy từ local còn chưa thì set là null như ban đầu 

SECTION 18: Login User Server
- Xử lý phần login ở server, unauthenticated , tạo file ở errors 
- so sánh bcrypt ở model luôn, tạo 1 hàm để so sánh 
- Các bước vẫn tương tự như đã biết( tìm user, ss pass ) ở controller


SECTION 19: Login phía client
- Tạo giống với register, cũng sẽ tạo action, appContext, ....

SECTION 25: Làm việc với authenticate
- video 112: do mỗi lần login sẽ tạo 1 token khác, nên setup trong postmand
dùng 1 token 
- tại register ở tab Test tạo:
{const jsonData = pm.response.json()
pm.globals.set("token", jsonData.token);}
copy vào login 

tất cả các route còn lại setup token để không cần copy lại

- Khi đã kiểm tra là có token rồi thì cần lấy token đó ra và so sánh
với mã đã tạo token nếu đúng gán nó cho req.user rồi next()
(MỤC đích của gán req.user là từ đây sẽ kiểm tra phải đúng userID này mới cho làm những việc tiếp)
- Tận dụng thời gian hết hạn của token để kiểm tra cái invalid

SECTION 26: Chi tiết phần update user
- Thêm logic ở authcontroller
- Sửa một chút điều kiện ở User (model) phần password
- this.modifiedPaths() khi có sự thay đổi từ ô nào thì nó sẽ log ra
- this.isModified('name') ô name có thay đổi thì nó trả về true, còn không thay đổi về false


SECTION 30: Bắt đầu xây dựng phần model Job
- video 129: Đã xong phần model, tiếp là contrller
- video 130: Làm ở phần contrller, test và chạy được với postmand
lưu được dữ liệu vào trong db

SECTION 32: Lấy tất cả job từ db
- video 139: Thêm logic cho phần cotroller getAllJobs

SECTION 35: Làm phần edit và delete job
- video 150, 151: Logic cho phần update mongoose cung cấp nhiều cách tiếp cận,
cần xem TH nào là phù hợp

- Video 152: V.đề: Tài khoản đăng ký khác có thể sửa được job của một tài khoản khác
(không phải của mình tạo)
+ Điều kiện, những job k phải mình tạo chỉ có thể xem
 
 - video 153: Cần kiểm tra loại của objectID ( cái này quan trọng vì để so sánh 2 cái với nhau)
 + Tạo 1 file để so sánh, checkPermission

 - video 154: delete controller
 + tương tự với edit thôi, chú ý nhé

 SECTION 37: Tạo 1 mockData
- video 157: Mockaroo: truy cập trang web makaroo.com để làm 1 fake data
+ Chú ý khi tạo fake data những trường tạo phải giống với model, 
kiểu dữ liệu lưu trữ chú ý cũng phải giống với ở trong mogodb

- video 158: Lấy data để kết nối và đẩy vào mogodb
+ Tạo 1 file populate.js có logic ở trong đó sử dụng mock-data đã tạo
và kết nối với model JOB, cùng db

SECTION 38: Tạo stats contrller
- video 160, 161: Mục đích của cuối cùng là làm sao để đếm ra stauts nào trùng nhau
tổng số lượng mỗi loại, và trả về cái đó

- video 162: Chú ý khi những người khác đăng nhập mà không phải tài khoản Đã đăng
thì sẽ không hiện số lượng status, chú ý phía giao diện người dùng
để nó là 0 ( nếu không thì nó sẽ hiện là underfied)

SECTION 40: Tiếp tục làm việc để hiển thị phần cột, data trả về cần được refactor
- 167, 168: Trả lời câu hỏi muốn server trả về cái gì, nhưng logic
bên trong phục vụ việc trả data về gọn hơn và sẽ dùng cho việc hiển thị giao diện

SECTION 42:
- Làm các chức năng sort, filter
- Chú ý một số mã check điều kiện của search (string)

- Sort sẽ là trường xếp cuối sau khi đã thỏa mãn các điều kiện serach,ư
 vì sau khi có kết quả thì mới thực hiện sắp xếp